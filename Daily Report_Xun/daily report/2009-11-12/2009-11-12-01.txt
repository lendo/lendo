1.在Java中，算术运算符 + 、- 、* 、/ 表示加减乘除。
  两个操作数都为整数，结果为整数。否则，为浮点数。
  整数求余操作为%。
  整数被0除，会产生异常，如：0/33 。
  浮点数被0除，会得到无穷大或非数值NaN结果，如：0/3.3 。
  赋值语句有种简化格式书写的二元运算符：*=，%=，+=。如：x += 4；即为：x = x + 4;
  Java语言可移植性很强。在任意虚拟机上运行结果一样。
  
2.Java中存在自增，自减运算：++ 、 -- 。
  在变量的前缀表示指：先进行加1运算，再参与运算。
  在变量的后缀表示指：使用变量原来的值参与运算，变量再自增1。
  
3.Java中的关系运算符和boolean运算符包括：
  = = （检测左右是否相等）、！=（检测左右是否不相等）、< (小于)、
  > (大于)、<= (小于等于)、>= (大于等于)、&& （逻辑"与"）、
  ||（逻辑"或"）、！=（逻辑"非"）。
  三元操作符：？： 表达式为：condition ? expression1 : expression2 。
  意思为：当条件condition为真时，计算expression1，否则计算expression2。
  
4.Java的位运算是针对处理整型数值。对数值的各个位操作。
  位运算符有：& （与）、| （或）、^ (异或)、~ （非）。
  上面4种位运算符计算返回的结果都是操作数的值1或0.
  & 和 | 与逻辑关系运算符 && 和 || 不同，前者返回值，后者返回true或false。
  >> (位右移)、<< （位左移）。
  
5.在Java源文件顶部加上这样的语句：
  import static java.lang.Math.*;
  就可以在整个程序内部使用数学函数了。
  使用StrictMath，可以在所有平台上得到相同的结果。
  
6.Java中两个数值进行二元操作时，数据类型必须一样。
  Java中的可以像如下方式进行转换：
  两个操作数有一个是double类型，另一个会转换为double类型。
  否则，没有double类型的情况下，
  如果其中一个是float类型，另一个会转换为float类型。
  否则，一个操作数是long类型，另一个会转换为long类型。
  否则，两个操作数都转换为int类型。 
  
7.强制类型转换的语法格式为：在圆括号（）中给出想要转换的目标类型，
  后面紧跟需要转换的变量名。
  强制类型转换时，如果超出了目标类型的表示范围，会成为另一个值。
  布尔类型和数值类型最好不要强制类型转换。
  
8.括号优先级最高；其次是非，自增自减，强制类型转换，new操作；
  其次是乘、除、求余；其次加、减；其次左右移，其次关系运算符；
  其次位运算，其次逻辑运算，其次三元运算符，最后二元运算符。
  同一级别优先级从左至右计算，右结合的三元运算符和二元运算符从右至左计算。
  
9.Java的字符串是Java类库中预定义类String来表示。

10.substring方法可以从一个字符串中提取子串。：String substring(int beginIndex,int endIndex)

11.Java语言中两个字符串可以用 + 号拼接，不含空格。
    一个字符串与一个变量用 + 拼接后，变量的值变为字符串。这种情况
    多用于输出语句：System.out.println();  。
    
12.String类对象称为不可变字符串，不能作修改。
   优点是可以共享字符串，变量都指向同一个存储位置即可。
   如果要修改字符串，Java中是用"构建字符串"类（StringBuilder），
   这个类使用的方法是：先 new StringBuilder()，再调用append方法，
   最后调用toString方法把字符串组合在一起。
   
13.检测两个字符串是否相等可以使用equals方法。
   如使用表达式："Hello".equals(greeting) 。
   不能用 = = 来检测字符串是否相等，这个运算符只是判断两个字符串存放的位置是否一样。
   字符串共享的话，因为存放位置是固定的，那么用 = = 始终都相等。
   
14.常用Unicode字符用一个代码单元就可以表示，
    辅助字符需要一对代码单元表示。
    代码点可能是1个代码单元，可能是1对代码单元表示。
    length方法用来计算字符串代码单元数量。
    计算代码点数量用codePointCount（参数1，参数2）方法，参数1为0，参数2可用length方法计算。
    charAt(n)方法返回位置n的代码单元，n介于 0~s.length()-1 之间。
    offsetByCodePoints(0,i)方法指从第一个元素到第i+1个元素返回第i+1个字符串。
    
15.Java应用程序编程接口是Java API。
   可以通过文档查看所有API方法，
   按照书上讲的方法，基本晓得怎么去查看API方法了，
   但英语还要加强，这个文档很重要。
   
16.要想在控制台进行输入，就需要构造一个Scanner对象in，
   与"标准输入流" System.in 关联。如：
   Scanner in = new Scanner(System.in);
   Scanner类在java.util包中，不在基本java.lang包中，
   所以在程序最开始要这样一行：
   import java.util.*；
   把java.util包加载进来。
   输入一行内容，用nextLine方法。如：String string = in.nextLine();
   输入一个单词，用next方法。
   输入整数，用nextInt。如：int age = in.nextInt();
   同理，浮点数用nextDouble方法。
  
17.格式化输出需要用语句 System.out.printf();
   格式说明符的语法为："%i(参数索引)$(在$后终止)标志（p55表3-6）宽度.{精度（小数后几位）转换字符（p54表3-5），t+日期转换字符（p55表3-7）}"
   String.format方法用于格式化字符串，但不printf打印输出。
   
    
-------------------------------------------------- Schedule ------------------------------------------------
1.（Q1）CLASSPATH 环境变量有什么用？我没设置，另外 JAVA_HOME 我也没设置。
       只设置了系统变量 PATH 指向的JDK路径。没设置这两个JDK编译运行也能完成，
       会不会有什么影响？
       设置JAVA_HOME，以后你的开发环境对其他的JAVA组件会更通用。
       但是你也可以不配置，因为在PATH中加入了JDK的安装目录\bin。
       系统就已经能够自动找到bin下面的所有命令。
       
      -----------------------lendo.du------------------------
      Classpath是在你的程序需要用的别人开发好的第三方包的时候，你需要把这个
       第三方包的文件位置放到classpath里面去，你的程序在编译的时候才能找到这
       些第三方包，classpath里面配置的是你的程序要编译和运行的依赖环境。
       注意这里不是配置Java的编译和运行环境，而是你代码里面的其他类的依赖环境。
       如果你现在不懂，你把这个问题保留，我过来会给你演示。
       ***************************************************
        你的回复：恩，演示了我可能就清楚些了。
                 听丹哥这么说，我有点把JAVA_HOME和CLASSPATH有点分不清了。
       ***************************************************
        这个问题你没有搞清楚，所以应该放到这里来。
      -----------------------lendo.du------------------------
      

2.（Q1）书中p39讲的通过运用2的冥次方的&运算可以将其他位屏蔽掉，
        只保留其中的某一位。对这句话，我不是很理解，如果可以的话
        还是想让丹哥演示下。  
        
   （Q2）书中讲的位运算，和>>>用0填充高位；>>用符号位填充高位。
         像这些用得多吗？有必要的话，最好丹哥也帮我演示下。     
        
        