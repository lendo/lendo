1.CLASSPATH 环境变量有什么用？我没设置，另外 JAVA_HOME 我也没设置。
  只设置了系统变量 PATH 指向的JDK路径。没设置这两个JDK编译运行也能完成，
  会不会有什么影响？
  设置JAVA_HOME，以后你的开发环境对其他的JAVA组件会更通用。
  但是你也可以不配置，因为在PATH中加入了JDK的安装目录\bin。
  系统就已经能够自动找到bin下面的所有命令。
       
  -----------------------lendo.du------------------------
  Classpath是在你的程序需要用的别人开发好的第三方包的时候，你需要把这个
  第三方包的文件位置放到classpath里面去，你的程序在编译的时候才能找到这
  些第三方包，classpath里面配置的是你的程序要编译和运行的依赖环境。
  注意这里不是配置Java的编译和运行环境，而是你代码里面的其他类的依赖环境。
  如果你现在不懂，你把这个问题保留，我过来会给你演示。
  ****************************************************
    你的回复：恩，演示了我可能就清楚些了。
             听丹哥这么说，我有点把JAVA_HOME和CLASSPATH有点分不清了。
  ****************************************************
  这个问题你没有搞清楚，所以应该放到这里来。
  -----------------------lendo.du------------------------
  ****************************************************
    你的回复：问题后面JAVA_HOME的注释应该是丹哥说的。听了昨天丹哥的
             解释，知道了JAVA_HOME的配置路径就是JDK的安装路径，即
             包含命令的文件夹的根目录。上面的注释说到：以后你的开发环境
             对其他JAVA组件会更通用。组件即编写好的用于其它网络服务的逻辑
             类，而组件的调用需要用到类似JBOSS或EJB或Web这样的中间件容器
             来实现。而对于容器的调用，同样需要用到JDK中提供的Java命令实现。
             所以，JAVA_HOME这个环境变量的设置，更多的是企业级的应用。对
             目前编写的简单小程序暂时不影响。
           CLASSPATH的配置则是针对自定义的类或者别人开发好的类，或者这样
             的类被打成第三方包。需要把这样存放的类或包的具体路径配置给CLASSPATH。
             这样如果程序在编译执行时，遇上这种不属于标准类库中的类时，那么就会
             从CLASSPATH中提供的路径去寻找相应的类，以便程序能继续执行下去。
             所以CLASSPATH中指向的类的路径，即是丹哥所说的程序要编译和运行的
             依赖环境。
             而PATH的配置则是Java的编译和运行环境，即指向Java所有命令的路径。
             这里我发现又有一个问题：昨天丹哥说的jre就是虚拟机，那为什么配置运行环境
             的PATH里没放入jre的路径。这里我估计的是bin文件夹下的Java命令就有
           Java虚拟机的命令，而jre是存放Java虚拟机程序的文件。丹哥看看是
             不是我想的这样。
  ****************************************************

2.（Q1）对书中讲的文件输入与输出这节，不清楚。
        书中讲的对文件进行读取时，代码为：Scanner in = new Scanner(new File("myfile.txt"));
        另外写入文件时，构造的PrintWriter对象。
        我通过编写代码试过，老出错，也不清楚原因，对这部分基本上都不明白。
        网上查了下资料，也是理论，没示例，最好丹哥来演示吧，顺便我再去网络上了解下。
        
        对文件的输入与输出，对文件进行输入要用到Java.io包中的PrintWriter类用一个文件初始化，
        并调用write方法实现，可以对文件内输入数据，完成后要调用close方法完成文件对象
        的清理。对文件中的内容输出，则要用到Java.util包中Scanner类，并在Scanner
        构造器中用File对象进行初始化，而File对象则是使用File类构造器用一个包含绝对路径
        或相对路径（相对路径没试过，可以试验下）下的文件来初始化得到File对象。最后用
        Scanner提供的方法，把文件内容显示在控制台上。
        如：java.util.Scanner in = new Scanner(new File("C:\\readme.txt"));
          String content = in.nextLine();
          System.out.println(content);
        文件写入，如：
           java.io.PrintWrite writeIn = new PrintWriter("C:\\readme.txt");
           writeIn.write(content);
           writeIn.close();
        另外，在对文件编写进行读取，写入代码时，编译时，Java编译器会告诉你这样的程序可能
        会出现无法找到文件或这样的文件并不存在的警告，为了完善程序，就需要在程序中加入发生
        异常时该如何处理的逻辑。比如在main方法中用throws子句标记：throws FileNotFoundException。
        （我可以试试如果我要读取或写入内容的这个文件我不去创建，看看程序如何运行。
          另外，我试试如果我不把另一个文件中的内容写入其他文件，我直接在源文件代码中写入
          内容，并把这样的内容写入一个文件中又能不能实现。）
          
3.（Q1）对switch语句的case标签该怎么表示不是很清楚。
       
       case标签的使用，在进行条件判断时标签应该用整数标签或者枚举常量标签。
        枚举类型的使用首先要用关键字enum声明枚举类型，
        再通过枚举类型定义枚举变量，把声明中的值或符号赋值给枚举变量。
        通过相应的逻辑关系后，最终标签中的常量符合多重选择的判读语句case，
        并执行case下的语句。
        在switch语句的case语句中，都需要包含break语句，否则，在执行到符合的判断
        语句case后，程序不会跳出并会接着继续执行以下的所有语句，造成期望值不符。
        需要注意，在使用switch语句时，在条件选择的最后需要加上default语句，
        并写上default下的语句，以便在程序进行多重选择时找不到对应选项时，执行
        default语句，返回默认结果。这样，程序会更加完善，更加不会出错，即是
        增加了程序的健壮性。
        
4.我在编写使用数学类的方法后，编译时出错，它说找不到符号，位置
  在类Math，是不是我这个jdk没有Math类？但我想不可能啊，具体原因
  我就不清楚了。
  
  在我编写使用数学类的程序时，犯下了一个致命的错误，即是把源文件名与标准库
  中类Math设置成一样的名字。也许是我在写代码时简单做了下实现计算代码，这
  时可能我并没有使用标准库类Math，以致编译成功，这时生成了目标文件Math.class。
  当我再在程序中编写我想调用的Math类时，这时程序就找不到定义的我这个Math类的方法，
  因为第一次编写时编译成功后生成了Math.class这个类文件，这是我自定义的，与标准库
  Math类文件完全沾不到边，所以，第2次编写的程序就从这里来调用查找。很显然是不可能
  找到相应常量或方法的。于是第2次肯定失败。当我们把源文件名重新修改并且删掉我第一次
  编译生成的Math.class时，理所应当的就执行成功了。
  
5.（Q4）按照书中所讲的构建字符串，我编写了程序希望把两个字符串组合在一起
        可是没有成功。编写代码为：
        public class Builder
        {
            public static void main(String[] args)
            {
                String war = "魔兽世界";
                StringBuilder builder = new StringBuilder(war);
                builder.append(Warcraft);
                builder.append(World);
                String completedString = builder.toString();
                System.out.println(completedString);
            }
        }
      
      我对这个通过构建器修改字符串的方法还是不太了解。我想把英文的加在
      中文后，实现的方法不清楚。
       
   在使用这个构建字符串的类时，对append方法参数的使用出现了问题，
   append方法参数需要时字符串或单个字符，而对于字符串的表示是要用
   ""或''包含表示，这样表示后才完完全全称作字符串或字符。而上例中
   我所表示的其实可以理解为一个字符串变量。所以最后导致程序错误。
   另外在对字符串进行构造时最好使用StringBuffer类，因为这个类对象
   是在内存中原有对象位置相应增加或减少内存地址，不像StringBuilder
   类是在不同的内存地址中生成对象，这样会使程序高效的执行，不会增加
   额外碎片。
   BTW：这里我有个问题，就是丹哥昨天说到的这个引号的优先级，什么比
         什么优先，所以被包含在什么，丹哥能不能再给我说说？
         
6.1.不能通过存在的对象调用构造器初始化实例域。
  -----------------lendo.du--------------------
  这句话是啥意思呢？
  ***************************************************
   你的回复：恩，对的，应该说清楚些，如果我不看书，单纯看这句话
            还是很难理解，对以后返回来学习可能多半很难懂。
            这句话我的理解就是如果程序编写时在实例域定义了对象，
            即这个对象是存在的。那么就不能用这个对象来调用构造器
            来初始化实例域，这样的操作时不符合语法的，对于构造器
            的调用必须在前面加上操作符 new 才行。
           BTW:对构造器这部分，书中说到了5个构造器相关的注意点。
                 我会再详细了解了书中关于构造器的例子后，自己尝试
                 做做。
  ***************************************************






















       













  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  